In Kubernetes, Pod-to-Pod communication typically happens through IP addresses assigned to Pods. However, using IP addresses is not scalable or practical, as Pods are ephemeral and can be rescheduled with new IPs. For easier and more reliable communication between Pods, Kubernetes provides **Fully Qualified Domain Names (FQDNs)**.

### How Pod-to-Pod Communication Works with FQDN in Kubernetes

1. **Pods in the Same Namespace:**
   - Pods can communicate with each other by their **Service name**.
   - Kubernetes automatically assigns **DNS names** to Services. When Pods in the same namespace need to communicate, you can use the Service name as an FQDN.
   - The format for a Service FQDN in the same namespace is:
     ```
     <service-name>.<namespace>.svc.cluster.local
     ```

   - In most cases, if Pods are in the same namespace, you don’t need the full FQDN and can just use the Service name:
     ```
     <service-name>
     ```

2. **Pods in Different Namespaces:**
   - For communication between Pods in different namespaces, you need to specify the full FQDN.
     ```
     <service-name>.<namespace>.svc.cluster.local
     ```

### Example Scenario: Pod-to-Pod Communication Using FQDN

Let’s assume we have two Pods:
- `app-pod` (a web application Pod)
- `db-pod` (a database Pod)

We will create a Service for each Pod to allow stable communication using FQDN.

#### Step 1: Create the `db-pod` (Database Pod)

**db-pod.yml**:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: db-pod
  labels:
    app: database
spec:
  containers:
  - name: mysql-container
    image: mysql:5.7
    env:
    - name: MYSQL_ROOT_PASSWORD
      value: "rootpassword"
    ports:
    - containerPort: 3306
```

Apply the pod configuration:
```bash
kubectl apply -f db-pod.yml
```

#### Step 2: Create a Service for the Database Pod

**db-service.yml**:
```yaml
apiVersion: v1
kind: Service
metadata:
  name: db-service
spec:
  selector:
    app: database
  ports:
  - protocol: TCP
    port: 3306
    targetPort: 3306
  type: ClusterIP
```

Apply the Service configuration:
```bash
kubectl apply -f db-service.yml
```

#### Step 3: Create the `app-pod` (Web Application Pod)

**app-pod.yml**:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
  labels:
    app: webapp
spec:
  containers:
  - name: webapp-container
    image: debian:latest
    command: ["/bin/sh"]
    args: ["-c", "while true; do sleep 3600; done"]
```

Apply the pod configuration:
```bash
kubectl apply -f app-pod.yml
```

#### Step 4: Test Communication Between Pods Using FQDN

To test communication between the `app-pod` and `db-pod` using the service name `db-service`, follow these steps:

1. Get into the `app-pod`:
   ```bash
   kubectl exec -it app-pod -- /bin/bash
   ```

2. Install the `mysql-client` inside the `app-pod` (optional):
   ```bash
   apt-get update && apt-get install -y mysql-client
   ```

3. Use the **FQDN** to connect to the `db-pod` via the `db-service`:
   ```bash
   mysql -h db-service -P 3306 -u root -p
   ```

   Alternatively, you can also use the full FQDN:
   ```bash
   mysql -h db-service.default.svc.cluster.local -P 3306 -u root -p
   ```

   Here:
   - `db-service` is the service name.
   - `default` is the namespace (use your namespace if different).
   - `svc.cluster.local` is the Kubernetes cluster domain.

### Key Takeaways:
- Pods in the **same namespace** can communicate with each other using just the **Service name**.
- For **cross-namespace communication**, use the full **FQDN** in the format:
  ```
  <service-name>.<namespace>.svc.cluster.local
  ```

This is how FQDN is used for reliable Pod-to-Pod communication in Kubernetes.
